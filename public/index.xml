<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ankit K</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Ankit K</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Feb 2026 16:45:19 +0530</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Basics of debugging slab memory corruption via SLUB debug</title>
      <link>http://localhost:1313/blog/debug-slub-memory/</link>
      <pubDate>Wed, 04 Feb 2026 16:45:19 +0530</pubDate>
      <guid>http://localhost:1313/blog/debug-slub-memory/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Memory corruption can occur due to various bugs or defects: Uninitialized Memory
Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory
leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/
execute) illegal memory regions.&lt;/p&gt;
&lt;p&gt;and memory is allocated in following hierarchy&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Page allocator → gives pages
SLUB → splits pages into objects
SLUB debug → adds metadata + checks
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since memory is dynamically allocated and freed via the kernel&amp;rsquo;s engine – the
page allocator. This can lead to serious wastage (internal fragmentation) of memory.
To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two
primary tasks – providing fragments of pages efficiently (within the kernel, allocation
requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux Kernel Mentorship Program</title>
      <link>http://localhost:1313/blog/linux-kernel-mentorship-program/</link>
      <pubDate>Mon, 08 Dec 2025 10:35:09 +0530</pubDate>
      <guid>http://localhost:1313/blog/linux-kernel-mentorship-program/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;I have been using Linux for the last two years and gradually developed an interest in systems programming and C. The mentorship prerequisites includes tasks like building and booting the Linux kernel, writing a basic kernel module, decoding stack traces, and modifying and booting a custom kernel build.&lt;/p&gt;
&lt;p&gt;Somehow, my application was accepted ;-).
&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/lfx-acceptance.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;At first, the Linux Kernel seemed quite difficult to understand what was going on. We were initially told to choose two subsystems to work on.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Misc Kernel Driver</title>
      <link>http://localhost:1313/blog/misc-kernel-driver/</link>
      <pubDate>Mon, 01 Dec 2025 22:32:00 +0530</pubDate>
      <guid>http://localhost:1313/blog/misc-kernel-driver/</guid>
      <description>&lt;h1 id=&#34;how-to-write-your-first-linux-kernel-driver-using-the-misc-device-framework&#34;&gt;How to Write Your First Linux Kernel Driver Using the Misc Device Framework&lt;/h1&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This article explains how to write a simple Linux kernel driver using the misc device framework. The misc framework is a good starting point because it automatically creates the device node when the driver registers, reducing setup complexity. In this example driver, a PID written from user space is stored in the kernel, and reading from the device triggers the driver to look up and display information about the corresponding task.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Install Ubuntu Server on Qemu</title>
      <link>http://localhost:1313/blog/install-ubuntu-server-on-qemu/</link>
      <pubDate>Sat, 16 Aug 2025 14:30:04 +0530</pubDate>
      <guid>http://localhost:1313/blog/install-ubuntu-server-on-qemu/</guid>
      <description>&lt;h1 id=&#34;installation-of-ubuntu-server-on-qemu-x86_64&#34;&gt;Installation of ubuntu server on qemu-x86_64&lt;/h1&gt;
&lt;p&gt;At First I want to run the custom modules on linux. But this is something that is not good to do on host machine. So i searched a lot of stuff. Tinkering with buildroot, after some days i was able to run the build on qemu.&lt;/p&gt;
&lt;p&gt;But i found out build actually didn’t have my basic tool like &lt;code&gt;gnu make&lt;/code&gt;. Everytime i try to do something i need to find particular tool on &lt;code&gt;menuconfig&lt;/code&gt; then make the build again. Learning was so slow.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
