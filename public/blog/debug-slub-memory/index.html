<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Basics of debugging slab memory corruption via SLUB debug | Ankit K</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
Memory corruption can occur due to various bugs or defects: Uninitialized Memory
Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory
leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/
execute) illegal memory regions.
and memory is allocated in following hierarchy
Page allocator → gives pages
SLUB → splits pages into objects
SLUB debug → adds metadata &#43; checks
Since memory is dynamically allocated and freed via the kernel&rsquo;s engine – the
page allocator. This can lead to serious wastage (internal fragmentation) of memory.
To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two
primary tasks – providing fragments of pages efficiently (within the kernel, allocation
requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/debug-slub-memory/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/debug-slub-memory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/blog/debug-slub-memory/">
  <meta property="og:site_name" content="Ankit K">
  <meta property="og:title" content="Basics of debugging slab memory corruption via SLUB debug">
  <meta property="og:description" content="Introduction Memory corruption can occur due to various bugs or defects: Uninitialized Memory Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/ execute) illegal memory regions.
and memory is allocated in following hierarchy
Page allocator → gives pages SLUB → splits pages into objects SLUB debug → adds metadata &#43; checks Since memory is dynamically allocated and freed via the kernel’s engine – the page allocator. This can lead to serious wastage (internal fragmentation) of memory. To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two primary tasks – providing fragments of pages efficiently (within the kernel, allocation requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2026-02-04T16:45:19+05:30">
    <meta property="article:modified_time" content="2026-02-04T16:45:19+05:30">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Basics of debugging slab memory corruption via SLUB debug">
<meta name="twitter:description" content="Introduction
Memory corruption can occur due to various bugs or defects: Uninitialized Memory
Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory
leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/
execute) illegal memory regions.
and memory is allocated in following hierarchy
Page allocator → gives pages
SLUB → splits pages into objects
SLUB debug → adds metadata &#43; checks
Since memory is dynamically allocated and freed via the kernel&rsquo;s engine – the
page allocator. This can lead to serious wastage (internal fragmentation) of memory.
To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two
primary tasks – providing fragments of pages efficiently (within the kernel, allocation
requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blog Articals",
      "item": "http://localhost:1313/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Basics of debugging slab memory corruption via SLUB debug",
      "item": "http://localhost:1313/blog/debug-slub-memory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Basics of debugging slab memory corruption via SLUB debug",
  "name": "Basics of debugging slab memory corruption via SLUB debug",
  "description": "Introduction Memory corruption can occur due to various bugs or defects: Uninitialized Memory Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/ execute) illegal memory regions.\nand memory is allocated in following hierarchy\nPage allocator → gives pages SLUB → splits pages into objects SLUB debug → adds metadata + checks Since memory is dynamically allocated and freed via the kernel\u0026rsquo;s engine – the page allocator. This can lead to serious wastage (internal fragmentation) of memory. To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two primary tasks – providing fragments of pages efficiently (within the kernel, allocation requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction Memory corruption can occur due to various bugs or defects: Uninitialized Memory Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/ execute) illegal memory regions.\nand memory is allocated in following hierarchy\nPage allocator → gives pages SLUB → splits pages into objects SLUB debug → adds metadata + checks Since memory is dynamically allocated and freed via the kernel’s engine – the page allocator. This can lead to serious wastage (internal fragmentation) of memory. To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two primary tasks – providing fragments of pages efficiently (within the kernel, allocation requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.\nThis blog will explain to debug a slab memory corruption via SLUB debug.\nRequirements We will be using the code example from https://github.com/ankitkhushwaha/Linux-Kernel-Debugging-tutorials So make sure to clone it.\nEnable CONFIG_SLUB_DEBUG Following configs are needed to use this feature.\n$ grep SLUB_DEBUG /boot/config-6.18.7-200.fc43.x86_64 CONFIG_SLUB_DEBUG=y # CONFIG_SLUB_DEBUG_ON is not set This config implies that SLUB debugging is available but disabled by default (as CONFIG_ SLUB_DEBUG_ON is off). It is Usually disabled in production due to overhead; enable only for debugging.\nThe slub_debug Kernel Parameter To leverage SLUB debug features we need to boot the kernel with slub_debug parameter.\nFlag Description Null(empty after slub_debug=) Switch all Slub debugging On. F Sanity checks (consistency checks) on SLUB objects. Detects basic corruption of the freelist or slab structure. Z Red zoning around objects (guard zones). Detects out-of-bounds (OOB) writes into adjacent memory areas. P Poisoning (object and padding areas). Detects access to uninitialized memory or use-after-free (UAF) errors when reallocating an object. U User tracking (store user info for alloc/free). Provides stack traces of the last allocation and free operations in bug reports, aiding root cause analysis. T Trace all allocations/frees. Use only on single slabs due to high verbosity. Provides detailed, continuous tracing of memory operations for a specific cache. A Toggle failslab filter mark for the cache. Used for testing error handling by simulating allocation failures. O Switch debugging off for caches that would cause higher minimum slab orders. Prevents debugging from forcing large page allocations, which can cause memory allocation errors in low-memory situations. - Switch all debugging off (useful if the kernel is compiled with CONFIG_SLUB_DEBUG_ON). Disables all debugging for specified caches or globally. Note - Kernel also provides way to enable flags for Specific slub inside ‘/sys/kernel/slab/slabname’ folder.\nUnderstanding the SLUB layer’s poison flags The poison flags defined by the kernel are defined as follows:\n// include/linux/poison.h /* ...and for poisoning */ #define POISON_INUSE 0x5a /* for use-uninitialised poisoning */ #define POISON_FREE 0x6b /* for use-after-free poisoning */ #define POISON_END 0xa5 /* end-byte of poisoning */ When you use the SLAB_POISON flag when creating a slab cache (typically via the kmem_cache_create() kernel API) or set poisoning to on via the kernel parameter slub_debug=P, the slab memory gets auto-initialized to the value 0x6b (which is ASCII k, corresponding to the POISON_FREE macro). In effect, when this flag is enabled, this (0x6b) is the value that valid but uninitialized slab memory regions are set to on creation. The POISON_INUSE value (0x5a equals ASCII Z) is used to denote padding zones, before or after red zones. The last legal byte of the slab memory object is set to POISON_END, 0xa5. Boot the Kernel Boot the kernel with slub_debug=FZPU\nAfter booting the kernel You should see something like this.\n$ cat /proc/cmdline BOOT_IMAGE=(hd0,gpt2)/vmlinuz-6.18.7-200.fc43.x86_64 root=UUID=94fc6fde-521c-4d20-9cba-84dba8146a75 ro rootflags=subvol=root slub_debug=FZPU quiet splash crashkernel=2G-64G:256M,64G-:512M Note: if kernel is build with KASAN support then it will catch the bug[discussed below] first. Try this in Production kernel built without KASAN support.\nReproduce the bug All test cases are defined in: ch5/kmembugs_test/kmembugs_test.c\n$ cd ch5/kmembugs_test $ sudo ./load_testmod # build \u0026 load the kernel module $ sudo ./run_tests # input the test number 5.2 [ 160.928464] testcase to run: 5.2 [ 160.928479] [Right Redzone overwritten] 0xffff8de137751680-0xffff8de137751683 @offset=1664. First byte 0x78 instead of 0xcc [ 160.928483] ============================================================================= [ 160.928485] BUG kmalloc-rnd-04-32 (Tainted: G OE ): Object corrupt [ 160.928487] ----------------------------------------------------------------------------- [ 160.928488] Allocated in dynamic_mem_oob_right+0x57/0xb0 [test_kmembugs] age=0 cpu=6 pid=7847 [ 160.928494] __kmalloc_cache_noprof+0x3ae/0x5c0 [ 160.928499] dynamic_mem_oob_right+0x57/0xb0 [test_kmembugs] [ 160.928501] dbgfs_run_testcase+0x2ee/0x3c0 [test_kmembugs] [ 160.928504] full_proxy_write+0x54/0x80 [ 160.928508] vfs_write+0xce/0x480 [ 160.928512] ksys_write+0x73/0xf0 [ 160.928514] do_syscall_64+0x7e/0x7f0 [ 160.928520] entry_SYSCALL_64_after_hwframe+0x76/0x7e [ 160.928524] Freed in rtw_iterate_vifs+0xa2/0xe0 [rtw88_core] age=2936 cpu=5 pid=1405 [ 160.928543] rtw_iterate_vifs+0xa2/0xe0 [rtw88_core] [ 160.928554] rtw_watch_dog_work+0x25a/0x320 [rtw88_core] [ 160.928562] process_one_work+0x192/0x350 [ 160.928566] worker_thread+0x25a/0x3a0 [ 160.928569] kthread+0xfc/0x240 [ 160.928571] ret_from_fork+0xf4/0x110 [ 160.928575] ret_from_fork_asm+0x1a/0x30 [ 160.928578] Slab 0xfffff6f104ddd440 objects=25 used=22 fp=0xffff8de137751de0 flags=0x17ffffc0000200(workingset|node=0|zone=2|lastcpupid=0x1fffff) [ 160.928583] Object 0xffff8de137751660 @offset=1632 fp=0xffff8de137751de0 [ 160.928585] Redzone ffff8de137751640: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ [ 160.928587] Redzone ffff8de137751650: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................ [ 160.928588] Object ffff8de137751660: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk [ 160.928590] Object ffff8de137751670: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5 kkkkkkkkkkkkkkk. [ 160.928591] Redzone ffff8de137751680: 78 cc cc 78 cc cc cc cc x..x.... [ 160.928592] Padding ffff8de1377516d4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a ZZZZZZZZZZZZ [...] [ 160.928946] ---[ end trace 0000000000000000 ]--- [ 160.928948] FIX kmalloc-rnd-04-32: Restoring Right Redzone 0xffff8de137751680-0xffff8de137751683=0xcc [ 160.928950] FIX kmalloc-rnd-04-32: Object at 0xffff8de137751660 not freed Test case\nint dynamic_mem_oob_right(int mode) { volatile char *kptr, ch = 0; char *volatile ptr; size_t sz = 32; kptr = kmalloc(sz, GFP_KERNEL); if (unlikely(!kptr)) return -ENOMEM; ptr = (char *)kptr + sz + 3; // right OOB if (mode == READ) { ch = *(volatile char *)ptr; ch = kptr[sz+3]; }\telse if (mode == WRITE)\t{ *(volatile char *)ptr = 'x'; // invalid, OOB right write kptr[sz] = 'x';\t// invalid, OOB right write } kfree((char *)kptr); return 0; } Test case performed a dynamic memory allocation of 32 bytes memory, and write a out of bound (OOB) region. First INFO line spits out the start and end of the corrupted memory region. Note that these kernel virtual addresses are hashed here, for security, preventing info leaks. Second INFO line shows where the buggy access took place in the code – via the usual +0xoff_from_func/0xlen_of_func [modname] notation. (Here, it happens to be dynamic_mem_oob_right+0x57/0xb0.\nWe haven’t shown the full stack call trace here. Read it bottom-up, ignoring any lines that begin with ‘?’.\nThe poison values are used if the poison flag (P) is set for the slab, as is the case here. Here, the poison value 0x6b denotes the value that’s used to initialize the valid slab memory region, 0xa5 denotes the end poisoning marker byte, and 0x5a denotes use-uninitialized poisoning. We have allocated a memory of 32 bytes shown by\n[ 160.928588] Object ffff8de137751660: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b kkkkkkkkkkkkkkkk [ 160.928590] Object ffff8de137751670: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5 kkkkkkkkkkkkkkk. The last byte was initialized with POISON_END bit (0xa5) and the value 0x78 is our x character being (wrongly) written by the test case outside of the allocated memory(circled the incorrect writes in the figure).\n[ 160.928591] Redzone ffff8de137751680: 78 cc cc 78 cc cc cc cc x..x.... Conclusion With SLUB_DEBUG enabled, it can be used to debug slab memory corruption. While it fails to catch some of the bugs. It is usefull in the production kernel to catch slab memory corruption without too much performance impact.\nReferences https://www.kernel.org/doc/Documentation/vvm/slub.txt https://www.oreilly.com/library/view/linux-kernel-debugging/9781801075039/ https://blogs.oracle.com/linux/linux-slub-allocator-internals-and-debugging-2 ",
  "wordCount" : "1290",
  "inLanguage": "en",
  "datePublished": "2026-02-04T16:45:19+05:30",
  "dateModified": "2026-02-04T16:45:19+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blog/debug-slub-memory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ankit K",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
<link rel="stylesheet" href="/css/custom.css" >

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Ankit K (Alt + H)">Ankit K</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/resume-ankit-khushwaha.pdf" title="Resume">
                    <span>Resume</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/resources" title="Resources">
                    <span>Resources</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Basics of debugging slab memory corruption via SLUB debug
    </h1>
    <div class="post-meta"><span title='2026-02-04 16:45:19 +0530 IST'>February 4, 2026</span>

</div>
  </header> 
  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Memory corruption can occur due to various bugs or defects: Uninitialized Memory
Reads (UMR), Use After Free (UAF), Use After Return (UAR), double-free, memory
leakage, or illegal Out Of Bounds (OOB) accesses that attempt to work upon (read/write/
execute) illegal memory regions.</p>
<p>and memory is allocated in following hierarchy</p>
<pre tabindex="0"><code>Page allocator → gives pages
SLUB → splits pages into objects
SLUB debug → adds metadata + checks
</code></pre><p>Since memory is dynamically allocated and freed via the kernel&rsquo;s engine – the
page allocator. This can lead to serious wastage (internal fragmentation) of memory.
To mitigate this, the slab allocator (or slab cache) is layered upon it, serving two
primary tasks – providing fragments of pages efficiently (within the kernel, allocation
requests for small pieces of memory, from a few bytes to a couple of kilobytes), and serving as a cache for commonly used data structures.</p>
<p>This blog will explain to debug a slab memory corruption via SLUB debug.</p>
<h1 id="requirements">Requirements<a hidden class="anchor" aria-hidden="true" href="#requirements">#</a></h1>
<p>We will be using the code example from <code>https://github.com/ankitkhushwaha/Linux-Kernel-Debugging-tutorials</code>
So make sure to clone it.</p>
<h1 id="enable-config_slub_debug">Enable CONFIG_SLUB_DEBUG<a hidden class="anchor" aria-hidden="true" href="#enable-config_slub_debug">#</a></h1>
<p>Following configs are needed to use this feature.</p>
<pre tabindex="0"><code>$ grep SLUB_DEBUG /boot/config-6.18.7-200.fc43.x86_64 
CONFIG_SLUB_DEBUG=y
# CONFIG_SLUB_DEBUG_ON is not set
</code></pre><p>This config implies that SLUB debugging is available but disabled by default (as CONFIG_
SLUB_DEBUG_ON is off). It is Usually disabled in production due to overhead; enable only for debugging.</p>
<h1 id="the-slub_debug-kernel-parameter">The slub_debug Kernel Parameter<a hidden class="anchor" aria-hidden="true" href="#the-slub_debug-kernel-parameter">#</a></h1>
<p>To leverage SLUB debug features we need to boot the kernel with slub_debug parameter.</p>
<table>
  <thead>
      <tr>
          <th>Flag</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Null(empty after slub_debug=)</td>
          <td>Switch all Slub debugging On.</td>
      </tr>
      <tr>
          <td>F</td>
          <td>Sanity checks (consistency checks) on SLUB objects. Detects basic corruption of the freelist or slab structure.</td>
      </tr>
      <tr>
          <td>Z</td>
          <td>Red zoning around objects (guard zones). Detects out-of-bounds (OOB) writes into adjacent memory areas.</td>
      </tr>
      <tr>
          <td>P</td>
          <td>Poisoning (object and padding areas). Detects access to uninitialized memory or use-after-free (UAF) errors when reallocating an object.</td>
      </tr>
      <tr>
          <td>U</td>
          <td>User tracking (store user info for alloc/free). Provides stack traces of the last allocation and free operations in bug reports, aiding root cause analysis.</td>
      </tr>
      <tr>
          <td>T</td>
          <td>Trace all allocations/frees. Use only on single slabs due to high verbosity. Provides detailed, continuous tracing of memory operations for a specific cache.</td>
      </tr>
      <tr>
          <td>A</td>
          <td>Toggle failslab filter mark for the cache. Used for testing error handling by simulating allocation failures.</td>
      </tr>
      <tr>
          <td>O</td>
          <td>Switch debugging off for caches that would cause higher minimum slab orders. Prevents debugging from forcing large page allocations, which can cause memory allocation errors in low-memory situations.</td>
      </tr>
      <tr>
          <td>-</td>
          <td>Switch all debugging off (useful if the kernel is compiled with CONFIG_SLUB_DEBUG_ON). Disables all debugging for specified caches or globally.</td>
      </tr>
  </tbody>
</table>
<p>Note - Kernel also provides way to enable flags for Specific slub inside &lsquo;/sys/kernel/slab/slabname&rsquo; folder.</p>
<h1 id="understanding-the-slub-layers-poison-flags">Understanding the SLUB layer&rsquo;s poison flags<a hidden class="anchor" aria-hidden="true" href="#understanding-the-slub-layers-poison-flags">#</a></h1>
<p>The poison flags defined by the kernel are defined as follows:</p>
<pre tabindex="0"><code>// include/linux/poison.h

/* ...and for poisoning */
#define POISON_INUSE    0x5a    /* for use-uninitialised poisoning */
#define POISON_FREE     0x6b    /* for use-after-free poisoning */
#define POISON_END      0xa5    /* end-byte of poisoning */
</code></pre><ul>
<li>When you use the SLAB_POISON flag when creating a slab cache (typically via the kmem_cache_create() kernel API) or set poisoning to on via the kernel parameter slub_debug=P, the slab memory gets auto-initialized to the value 0x6b (which is ASCII k, corresponding to the POISON_FREE macro). In effect, when this flag is enabled, this (0x6b) is the value that valid but uninitialized slab memory regions are set to on creation.</li>
<li>The POISON_INUSE value (0x5a equals ASCII Z) is used to denote padding zones, before or after red zones.</li>
<li>The last legal byte of the slab memory object is set to POISON_END, 0xa5.</li>
</ul>
<h1 id="boot-the-kernel">Boot the Kernel<a hidden class="anchor" aria-hidden="true" href="#boot-the-kernel">#</a></h1>
<p>Boot the kernel with <code>slub_debug=FZPU</code></p>
<p>After booting the kernel You should see something like this.</p>
<pre tabindex="0"><code>$ cat /proc/cmdline 
BOOT_IMAGE=(hd0,gpt2)/vmlinuz-6.18.7-200.fc43.x86_64 root=UUID=94fc6fde-521c-4d20-9cba-84dba8146a75 ro rootflags=subvol=root slub_debug=FZPU quiet splash crashkernel=2G-64G:256M,64G-:512M
</code></pre><p>Note: if kernel is build with KASAN support then it will catch the bug[discussed below] first.
Try this in Production kernel built without KASAN support.</p>
<h1 id="reproduce-the-bug">Reproduce the bug<a hidden class="anchor" aria-hidden="true" href="#reproduce-the-bug">#</a></h1>
<p>All test cases are defined in: <code>ch5/kmembugs_test/kmembugs_test.c</code></p>
<pre tabindex="0"><code>$ cd ch5/kmembugs_test
$ sudo ./load_testmod     # build &amp; load the kernel module
$ sudo ./run_tests        # input the test number
5.2
[  160.928464] testcase to run: 5.2
[  160.928479] [Right Redzone overwritten] 0xffff8de137751680-0xffff8de137751683 @offset=1664. First byte 0x78 instead of 0xcc
[  160.928483] =============================================================================
[  160.928485] BUG kmalloc-rnd-04-32 (Tainted: G           OE      ): Object corrupt
[  160.928487] -----------------------------------------------------------------------------

[  160.928488] Allocated in dynamic_mem_oob_right+0x57/0xb0 [test_kmembugs] age=0 cpu=6 pid=7847
[  160.928494]  __kmalloc_cache_noprof+0x3ae/0x5c0
[  160.928499]  dynamic_mem_oob_right+0x57/0xb0 [test_kmembugs]
[  160.928501]  dbgfs_run_testcase+0x2ee/0x3c0 [test_kmembugs]
[  160.928504]  full_proxy_write+0x54/0x80
[  160.928508]  vfs_write+0xce/0x480
[  160.928512]  ksys_write+0x73/0xf0
[  160.928514]  do_syscall_64+0x7e/0x7f0
[  160.928520]  entry_SYSCALL_64_after_hwframe+0x76/0x7e
[  160.928524] Freed in rtw_iterate_vifs+0xa2/0xe0 [rtw88_core] age=2936 cpu=5 pid=1405
[  160.928543]  rtw_iterate_vifs+0xa2/0xe0 [rtw88_core]
[  160.928554]  rtw_watch_dog_work+0x25a/0x320 [rtw88_core]
[  160.928562]  process_one_work+0x192/0x350
[  160.928566]  worker_thread+0x25a/0x3a0
[  160.928569]  kthread+0xfc/0x240
[  160.928571]  ret_from_fork+0xf4/0x110
[  160.928575]  ret_from_fork_asm+0x1a/0x30
[  160.928578] Slab 0xfffff6f104ddd440 objects=25 used=22 fp=0xffff8de137751de0 flags=0x17ffffc0000200(workingset|node=0|zone=2|lastcpupid=0x1fffff)
[  160.928583] Object 0xffff8de137751660 @offset=1632 fp=0xffff8de137751de0

[  160.928585] Redzone  ffff8de137751640: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
[  160.928587] Redzone  ffff8de137751650: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc  ................
[  160.928588] Object   ffff8de137751660: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
[  160.928590] Object   ffff8de137751670: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.
[  160.928591] Redzone  ffff8de137751680: 78 cc cc 78 cc cc cc cc                          x..x....
[  160.928592] Padding  ffff8de1377516d4: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a              ZZZZZZZZZZZZ

[...]

[  160.928946] ---[ end trace 0000000000000000 ]---
[  160.928948] FIX kmalloc-rnd-04-32: Restoring Right Redzone 0xffff8de137751680-0xffff8de137751683=0xcc
[  160.928950] FIX kmalloc-rnd-04-32: Object at 0xffff8de137751660 not freed
</code></pre><p>Test case</p>
<pre tabindex="0"><code>int dynamic_mem_oob_right(int mode)
{
	volatile char *kptr, ch = 0;
	char *volatile ptr;
	size_t sz = 32;
	
	kptr = kmalloc(sz, GFP_KERNEL);
	if (unlikely(!kptr))
		return -ENOMEM;
	
	ptr = (char *)kptr + sz + 3; // right OOB
	
	if (mode == READ) {
	ch = *(volatile char *)ptr;
	ch = kptr[sz+3];
	}	
	else if (mode == WRITE)	{
		*(volatile char *)ptr = &#39;x&#39;;  // invalid, OOB right write
		kptr[sz] = &#39;x&#39;;	// invalid, OOB right write
	}
	
	kfree((char *)kptr);
	return 0;
}
</code></pre><p>Test case performed a dynamic memory allocation of 32 bytes memory, and write a out of bound (OOB) region.
First INFO line spits out the start and end of the corrupted memory region. Note
that these kernel virtual addresses are hashed here, for security, preventing info leaks.
Second INFO line shows where the buggy access took place in the code – via the
usual <!-- raw HTML omitted -->+0xoff_from_func/0xlen_of_func [modname] notation. (Here,
it happens to be dynamic_mem_oob_right+0x57/0xb0.</p>
<p>We haven&rsquo;t shown the full stack call trace here. Read it bottom-up, ignoring any lines that
begin with &lsquo;?&rsquo;.</p>
<p><img alt="alt text" loading="lazy" src="/slab-memory.png"></p>
<p>The poison values are used if the poison flag (P) is set for the slab, as is the case here. Here, the poison value 0x6b denotes the value that&rsquo;s used to initialize the valid slab memory region, 0xa5
denotes the end poisoning marker byte, and 0x5a denotes use-uninitialized poisoning.
We have allocated a memory of 32 bytes shown by</p>
<pre tabindex="0"><code>[  160.928588] Object   ffff8de137751660: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk
[  160.928590] Object   ffff8de137751670: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.
</code></pre><p>The last byte was initialized with POISON_END bit (0xa5) and the value 0x78 is our x character being (wrongly) written by the test case outside of the allocated memory(circled the incorrect writes in the figure).</p>
<pre tabindex="0"><code>[  160.928591] Redzone  ffff8de137751680: 78 cc cc 78 cc cc cc cc                          x..x....
</code></pre><h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>With SLUB_DEBUG enabled, it can be used to debug slab memory corruption. While it fails to catch some of the bugs.
<img alt="alt text" loading="lazy" src="/slab-memory-detect.png"></p>
<p>It is usefull in the production kernel to catch slab memory corruption without too much performance impact.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/vvm/slub.txt">https://www.kernel.org/doc/Documentation/vvm/slub.txt</a></li>
<li><a href="https://www.oreilly.com/library/view/linux-kernel-debugging/9781801075039/">https://www.oreilly.com/library/view/linux-kernel-debugging/9781801075039/</a></li>
<li><a href="https://blogs.oracle.com/linux/linux-slub-allocator-internals-and-debugging-2">https://blogs.oracle.com/linux/linux-slub-allocator-internals-and-debugging-2</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Ankit K</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/ankitkhushwaha/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
